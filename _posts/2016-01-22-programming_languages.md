---
layout: post
title: 你应该选择什么语言?
category: design patterns
---

各种语言使用场景不同, 每个团队知识背景不同, 因此这个问题没有统一的答案, 这里只是摘抄一些各种语言的特点.

### PHP与Python/Ruby的区别

PHP和Python/Ruby的运行机制有一个本质区别：PHP是每次HTTP请求过来以后，初始化全部资源（例如创建数据库链接、加载系统类库，创建缓存等等），处理完毕，释放全部资源，这不像Python/Ruby之类带有GC的脚本语言，Python/Ruby是初次启动的时候初始化资源，随后的请求就不必再次初始化资源了。

这种机制的差异带来的区别就是：

1、PHP极难出现严重的内存泄露问题，随便你代码写的多烂，反正每个请求一执行完毕，所有资源统统释放光。而Python/Ruby则需要依赖GC来回收内存，因此稍有不慎，还是会出现GC无法释放的内存泄露问题。

2、PHP每次请求都要初始化资源，这个开销非常大。所以尽管PHP解析器本身的运行速度是极快的，但是一旦使用复杂的PHP框架，那么由于需要每次请求的时候初始化整个框架，性能的下降非常厉害，你用一个很复杂的PHP框架的结果就是整体性能被Ruby远远甩开。这也是为什么PHP社区这么多年来，并不怎么倾向于使用框架的原因之一。

3、由于PHP这种每请求初始化资源的机制，也造成了PHP添加跨请求的高级特性相当困难，这是PHP本身一个很大的限制，但是反过来说，正是这种限制使得PHP始终保持在一个比较简单的web语言上面，而正是这一点才是PHP得以成为互联网第一Web编程语言的原因，因此也未必就不好。

总之，PHP和Ruby的差异还是很大的，不适合放在一起比较，其实应该比较的是Ruby和Python才对

### Python与Ruby本质上不同 - 简约语言与魔幻语言

本节选自孟岩的文章[Ruby 1.9不会杀死Python](http://blog.csdn.net/myan/article/details/2028545)和Robbin的文章[Ruby为什么会受程序员的欢迎？](http://robbin.iteye.com/blog/153749)

简约语言是什么呢？大致上是C、PHP、Python和Lua，C# ，Java，Python, 他的大概意含可以由Python的中心思想EIBTI可以略知一二:

  Explicit is better than implicit.

白话一点就是, 完成一个工作大约只有一个方法. 也就是，Python 有意的限制语言的表示方式，使得不好的coding 习惯都不能Compile 过，有意的强制使用者养成良好的习惯

魔幻语言的代表有C++、Perl、Javascript和Ruby, 中心思想可以由Perl 的TMTOWTDI 来表示

  There's More Than One Way To Do It.

相同目的的代码可能有多样化的写法.

C++的魔幻语法会导致代码的可读性变差，而Ruby的魔幻语法会导致代码的可读性大大提高.

### web选型

* j2ee/struts/spring/hibernate
* php/lamp/lnmp
* RoR
* python/tornado
* node.js/MEAN

后端推荐springboot或者国内的dubbo, 对于前端，框架也分CSS框架和JS框架:

* CSS框架可以采用Bootstrap，Foundation等, CSS通过less或者sass开发也比较方便
* JS框架的话，可以采用Angular，React，Vue.js

其他一些语言:

* go
* Haskell
* Erlang

### Web服务并发模型

* 多进程（Multi-Process）
    * 该并发模型是目前使用得最广泛的模型，各种语言基本都支持。每个进程一次处理一个请求，并发能力等于进程数。
    * 优点：并发模型简单，由操作系统负责调度，稳定健壮；易管理，相关进程管理工具齐全；隔离性好，进程之间不会互相影响；代码兼容性好，无需考虑线程安全问题；能有效利用多核CPU，实现并行计算。
    * 缺点：由于单个进程需要加载完整应用，内存消耗大；进程间的切换开销较大；并发能力受限于系统进程数，比较低；单个请求处理需要非常快，否则很容易达到并发上限。
    * 支持语言：PHP、Python、Ruby
* 多线程（Multi-Thread）
    * 这种模型是Java和.Net的常用模型。在重量级的进程里启动多个轻量级的线程，一个线程处理一个请求，并发能力等于线程数。
    * 优点：多个线程间共享进程资源，内存消耗较低；线程间切换开销较小；并发能力较高；能有效利用多核CPU，实现并行计算。
    * 缺点：应用代码及其用到的库必须是线程安全的；对共享资源的操作需要加锁，容易产生死锁问题；对虚拟机的内存管理要求很高，容易出现内存泄漏。
    * 支持语言：Java、.Net
* 多进程+多线程（Multi-Process+Multi-Thread）
    * 该模型的出现是由于脚本语言（Python、Ruby）中普遍存在的全局解释器锁（GIL），导致一个进程内的多个线程无法同时在CPU的多个核上运行。通过启动多个进程，然后在单个进程内启动多个线程，既能充分利用多核CPU的计算能力，又提高了并发能力。一般启动的进程数等于CPU核数。该模型结合了多进程和多线程模型的优缺点。
* 事件驱动（Event I/O）
    * 该模型利用通常应用中I/O操作的时间远大于CPU计算时间，在某个请求处于I/O等待状态时，把CPU资源分配给其它请求，从而将原本串行的请求处理变成了交叉处理，提高了CPU使用率的同时也提高了并发能力。
    * 优点：极高的并发能力，单机可以处理上万的并发连接；内存消耗低，单进程单线程，无需保存场景；资源消耗低，没有场景切换开销。
    * 缺点：需要使用异步编程方式，代码不易编写，且难于维护；所用库必须为异步；不适合CPU密集型应用；只能在单核上运行，无法利用多核CPU计算能力。
    * 支持语言：Python、Ruby、Java、.Net、Node.js
* 协程（Coroutine）
    * 协程模型本质上也是事件驱动，是对“事件驱动”模型的高级封装，通过“协程”降低异步编程的复杂性。协程存在于用户空间，操作系统并不原生支持，因此协程的调度需要应用自己来负责。除了编程方式使用常见的同步方式而不是异步之外，其优缺点跟“事情驱动”模型基本一致。
    * 支持语言：Ruby、Scala、Go、Lua原生支持，Python和Node.js通过第三库支持