---
layout: post
title: 正则表达式
tag: javascript
---

### 正则表达式引擎

正则表达式引擎是一种可以处理正则表达式的软件，linux, php, perl, python, java, C++, .net等各种语言都支持正则表达式，需要注意的是许多引擎很类似，但不完全一样，支持的正则表达式语法可能有细微的差别。

有两种类型的引擎：文本导向(text-directed)的引擎和正则导向(regex-directed)的引擎。一些非常有用的特性，如“惰性”量词(lazy quantifiers)和反向引用(backreferences)，只能在正则导向的引擎中实现，因此正则导向的引擎是目前最流行的引擎。

你可以轻易分辨出所使用的引擎是文本导向还是正则导向。如果反向引用或“惰性”量词被实现，则可以肯定你使用的引擎是正则导向的。你可以作如下测试：将正则表达式`regex|regex not`应用到字符串“regex not”, 如果匹配的结果是regex, 则引擎是正则导向的, 如果结果是regex not，则是文本导向的。因为正则导向的引擎是“猴急”的，它会很急切的进行表功，报告它找到的第一个匹配。正则导向的引擎总是返回最左边的匹配, 即使以后有可能发现一个“更好”的匹配，正则导向的引擎也总是返回最左边的匹配

### 文字符号

最基本的正则表达式就是一个字符或字符串，譬如`a`，将会匹配字符串"Paradise in Heaven, Suzhou and Hanzhou on earth"里的第一个a，字符串`ou`将匹配字符串Suzhou里的ou，而不会匹配Hangzhou里的ou.

正则表达式引擎缺省是**大小写敏感**的。除非你告诉引擎忽略大小写，否则`suzhou`不会匹配“Suzhou”.

#### 特殊字符

有12个字符被保留作特殊用途,这些特殊字符也被称作元字符。他们是：``[ ] \ ^ $ . | ? * + ( )`` 如果需要匹配这些元字符，需要用 \ 转义.

<table class="ink-table bordered hover alternating">
  <thead>
    <tr>
      <th class="align-left">元字符</th>
      <th class="align-left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>\</td>
      <td>表示转义</td>
    </tr>
    <tr>
      <td>[ ]</td>
      <td>表示字符集</td>
    </tr>
    <tr>
      <td>^</td>
      <td>用在字符集里紧跟"["表示对字符集取反，另一个用法是表示匹配第一个字符</td>
    </tr>
    <tr>
      <td>? * +</td>
      <td>表示重复, ?表示重复0次或1次, *表示重复0次或多次, +表示重复1次或多次</td>
    </tr>
    <tr>
      <td>.</td>
      <td>表示任意字符，等于是字符集[^\n\r](Window)或[^\n]( Unix)的简写</td>
    </tr>
    <tr>
      <td>^ $</td>
      <td>^表示匹配第一个字符, $表示匹配最后一个字符. `^a`将会匹配字符串“abc”中的a，`^b`将不会匹配“abc”中的任何字符，`c$`匹配“abc”中的c</td>
    </tr>
    <tr>
      <td>|</td>
      <td>表示或</td>
    </tr>
    <tr>
      <td>( )</td>
      <td>表示字符组</td>
    </tr>
  </tbody>
</table>

#### 特定含义的字符

* 不可见字符:
    * \t 代表Tab(0x09)
    * \r 代表回车符(0x0D)
    * \n 代表换行符(0x0A), 要注意的是Windows中文本文件使用“\r\n”来结束一行而Unix使用“\n”
    * \f 代表换页符
    * \v 代表垂直制表符
* 字符集简写:
    * \d 代表数字，与`[0-9]`等效
    * \w 代表单词字符，与`[A-Za-z0-9_]`等效
    * \s 代表空白字符，与`[\f\n\r\t\v]`等效
    * \D 表示取反\d, `[\D]` = `[^\d]`
    * \W 表示取反\w, `[\W]` = `[^\w]`
    * \S 表示取反\s, `[\S]` = `[^\s]`
* 单词边界:
    * \b 表示单词边界，`\bis\b`将匹配字符串“This island is beautiful”里的单独的is，不会匹配This和island里的is
    * \B 表示非单词边界，`er\B`能匹配“verb”中的“er”，但不能匹配“never”中的“er”
* 字符串开始与结束:
    * \A 表示字符串开头，类似^
    * \Z 表示字符串结尾，类似$

### 字符集

字符集是由一对方括号“[ ]”括起来的字符集合。使用字符集，你可以告诉正则表达式引擎仅仅匹配多个字符中的一个。你可以使用`gr[ae]y`匹配gray或grey，`gr[ae]y`将不会匹配graay或graey.

#### 用连字符-定义字符范围

字符集里可以使用连字符“-”定义一个字符范围,`[0-9]`匹配0到9之间的单个数字。你可以使用不止一个范围。`[0-9a-fA-F]`匹配单个的十六进制数字，并且大小写不敏感。你也可以结合范围定义与单个字符定义。`[0-9a-fxA-FX]`匹配一个十六进制数字或字母X。再次强调一下，字符和范围定义的先后顺序对结果没有影响

#### 取反字符集

在左方括号“[”后面紧跟一个尖括号“^”，将会对字符集取反，字符集里如果"^"没有紧跟"[",则不表示取反。`q[^u]`意味着：匹配一个q，后面跟着一个不是u的字符。所以它不会匹配“Iraq”中的q，而会匹配“Iraq is a country”中的q和一个空格符.

#### 字符集里的元字符

正则表达式有12个元字符，但在字符集中只有4个字符具有特殊含义，它们是：“] \ ^ -”。“]”代表字符集定义的结束；“\”代表转义；“^”代表取反；“-”代表范围定义。其他常见的元字符在字符集定义内部都是正常字符，不需要转义。例如，要搜索星号*或加号+，你可以用`[+*]`。当然，如果你对那些通常的元字符进行转义，你的正则表达式一样会工作得很好，但是这会降低可读性

### 字符重复

元字符"? + *"表示字符重复:

* ?：告诉引擎匹配前导字符0次或一次
* +：告诉引擎匹配前导字符1次或多次
* *：告诉引擎匹配前导字符0次或多次

正则表达式`[0-9]+`可以匹配837或222等1位以上的数字, `<[A-Za-z][A-Za-z0-9]*>`匹配没有属性的HTML标签，“<”以及“>”是文字符号。第一个字符集匹配一个字母，第二个字符集匹配一个字母或数字.

许多现代的正则表达式实现，都允许你定义对一个字符重复多少次。词法是：{min,max}。min和max都是非负整数。如果逗号有而max被忽略了，则max没有限制。如果逗号和max都被忽略了，则重复min次。因此{0,}和*一样，{1，}和+ 的作用一样。你可以用`\b[1-9][0-9]{3}\b`匹配1000~9999之间的数字(“\b”表示单词边界)。`\b[1-9][0-9]{2,4}\b`匹配一个在100~99999之间的数字.

### 组

把正则表达式的一部分放在圆括号( )内，你可以将它们形成组。然后你可以对整个组使用一些正则操作，例如重复操作符

### 更多资料:

* <http://dragon.cnblogs.com/archive/2006/05/08/394078.html>